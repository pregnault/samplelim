---
title: "High dimensional polytope sampling with samplelim"
author: "Jacques Bréhélin, Philippe Regnault"
format: html
toc: true
vignette: >
  %\VignetteIndexEntry{High dimensional polytope sampling with samplelim}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

## Describing the polytope to sample

A polytope $\mathcal{P}$ is an $n$-dimensional convex set defined as the intersection of hyper-planes and half-spaces. 
More precisely, $\mathcal{P} = \{ x \in \mathbb{R}^n: Ax = B, Gx \geq H \}$, 
where $A$ is an $m\times n$ matrix, with $m \leq n$, $B \in \mathbb{R}^m$, $G$ is a $k \times n$ matrix, with $k \geq 0$ and $H \in \mathbb{R}^k$.

Inequality constraints, represented by the matrix $G$, involved in linear inverse models for metabolic networks make the polytope bounded.

The main argument `lim` of `rlim()` is a list with (at least) four components named `A`, `B`, `G` and `H`, the matrices and vectors defining the polytope to be sampled. Right below is a minimal example.

```{r minimalexample}
library("samplelim")
# Define equality and inequality constraints through matrices A, B, G, H
A <- matrix(rep(1, 3L), nrow = 1, ncol = 3)
B <- 1
G <- -matrix(c(0,0,1,
              0, 0, -1,
              0, 1, 0, 
              0, -1, 0,
              1, 0, 0, 
              -1, 0, 0),
            byrow = TRUE,
            nrow = 6, ncol = 3)
H <- -matrix(c(0.7, 0, 0.8, 0, 0.8, 0), nrow = 6)
# Store into a list
lim_exm <- list(A = A, B = B,G = G,H = H)
# Sampling into the polytope defined by these constraints
sample <- rlim(lim_exm, seed = 123)
# Show first points of the sample
head(sample)
```

In the previous -- pedagogical, example, we can visualize the sample generated by `rlim()` thanks to a 3D scatterplot.

```{r vizminexm, message = FALSE}
# Preparing sample for 3D scatterplot
colnames(sample) <- c("X", "Y","Z")
sample <- as.data.frame(sample)
library("plotly")
plot_sample <- plot_ly(sample, x = ~X, y = ~Y, z = ~Z, size = 0.2)
plot_sample <- plot_sample %>% add_markers()
plot_sample <- plot_sample %>% layout(title = "Estimation of the polytope using sample points")
plot_sample
```

## Sampling the polytope for a model defined in a file

First we import our model saved in DeclarationFileBOWF-short.txt file and we convert it to a `lim` object.

```{r examplefileimport}
DF <- system.file("extdata", "DeclarationFileBOWF-short.txt", package = "samplelim")
model <- df2lim(DF)
```

We can check all the attributes of our model.

```{r examplefileattributes}
att <- attributes(model)
att
```

For example variable names.

```{r variable_name}
model$Variables
```

We can determine theoretical ranges of each variable using `lim.ranges()`. It provides a lower bound, an upper bound, and the length of the interval between these bounds.

```{r examplefileranges}
lim.ranges(model)
```

We can sample the polytope using `rlim()`.

```{r}
sample <- rlim(model, nsamp=5000, seed = 123)
head(sample)
```
## Evaluating the quality of a sample using performance diagnostics

There are multiple diagnostics to evaluate the convergence of a Monte Carlo Markov Chain, those are applied to the sequences of draws, and performed separately for each variable, inducing some insight on the uniformity of the distribution. Here are some examples:

### The Raftery and Lewis diagnostic

```{r RL_diag}
coda::raftery.diag(data = sample)
```

### The Geweke diagnostic

```{r geweke_diag}
coda::geweke.diag(sample)
```

### Effective Sample Size

The Effective Sample Size (ESS) reflects the amount of autocorrelation in the MCMC draws. The closer the ESS is to N (where N is the sample size), the better, because it means that the draws are lowly autocorrelated.

```{r ESS_diag}
coda::effectiveSize(sample)
```

## Adjusting sampling methods and parameters

### Choosing the sample size and sampling method

By default, `rlim()` samples 3000 points using the Mirror Walk algorithm, the sample size can be adjusted and the Billard Walk algorithm can be used instead.

```{r adjusting_ex1, eval = FALSE}
# Set the number of points to sample to 10000 using nsamp
big_sample <- rlim(model, nsamp = 10000, seed = 123)
dim(big_sample)
# Use the Billard Walk algorithm by specifying "BiW" for the type
billard_sample <- rlim(model, type = "BiW", seed = 123)
```

### Parameters of the chain

To achieve a sample closer to a uniform distribution, we usually employ two parameters: the burn-in (`burn`) parameter, which discards initial values, and the thinning parameter (`thin`), which retains samples at specific intervals.

```{r adjusting_ex2, eval = FALSE}
burn <- 1000
thin <- 50
burned_and_thinned <- rlim(model, nsamp = 10000, burn=burn, thin=thin, seed = 123)
```


### Adjusting the value of the jump

Jump (`jmp`) is an important parameter, if its value is too small the chain may struggle to efficiently explore the polytope. Conversely, if the jump is too big the sampling process could take time because the trajectory of the chain may reach borders of the polytope and hence many reflections will need to be computed. 

In the Billard Walk algorithm the jump value is a numeric value whereas in the Mirror Walk, a numeric vector needs to be used.

Finding an optimal value for the jump is difficult, so the most simple approach is to test a set of specific values for it and evaluate them with performance diagnostics (for example ESS).

```{r adjusting_ex3, eval = FALSE}

```

## Working with the reduced polytope

Sampling process uses a reduced polytope. The polytope $\mathcal{P} = \{ x \in \mathbb{R}^n: Ax = B, Gx \geq H \}$ is reduced as a polytope
$\mathcal{P'} = \{ x \in \mathbb{R}^{n-k}: G'x \geq H' \}$, where the matrix $Z$ is the basis of the right null space of $A$, $x_0$ is a particular solution of $\mathcal{P}$, the matrix $G' = GZ$, the vector $H' = H-Gx_0$ and $k$ the rank of the matrix $A$.

> **Note:** The following section is more theoretical and advanced. Studying the reduced polytope can have an interest but it is difficult to interpret for applications in a concrete field.

We can reduce the full polytope and obtain the components describing the reduced polytope using `lim.redpol()`.

```{r projected_polytope_example}
# Get the full polytope
DF <- system.file("extdata", "DeclarationFileBOWF-short.txt", package = "samplelim")
full <- df2lim(DF)
# Project the polytope
reduced <- lim.redpol(full)
# Let's compare the shape of the constraint matrixes of the two polytopes
# full
dim(full$G)
# projected
dim(reduced$G)
```

```{r get_project_polytope_comps, eval = FALSE}
# Get k the rank of the matrix A
k <- qr(full$A)$rank
# Get the Z matrix
reduced$Z
# Get the particular solution x0
reduced$x0
# Get the matrix G'
reduced$G
# Get the vector H'
reduced$H
```

We can now sample the reduced polytope, and turn this sample back to a sample of the full polytope using `red2full()` by giving the particular solution $x_0$ and the matrix $Z$.

```{r red2full_example}
# Sampling the reduced polytope
sample_reduced <- rlim(reduced, seed = 123)
head(sample_reduced)
# Turn sampled points of the reduced polytope into sampled points of the full polytope
sample_full <- red2full(sample_reduced, reduced$x0, reduced$Z)
```

A sample of the full polytope can also be turned into a sample of the reduced polytope with `full2red()`.

```{r full2red_example}
sample_reduced2 <- full2red(sample_full,reduced$x0, reduced$Z)
```

